import type { QAReviewData } from "../jobs.js";
import { enqueueDevelopFeature, enqueueNotifyHuman } from "../jobs.js";
import * as featureService from "../../services/feature.service.js";
import * as initiativeService from "../../services/initiative.service.js";
import { runQAAgent } from "../../agents/qa.agent.js";
import * as githubService from "../../services/github.service.js";
import { QA_MAX_REJECTION_RETRIES } from "../../config/constants.js";
import { createChildLogger } from "../../lib/logger.js";

const log = createChildLogger({ handler: "qa-review" });

export async function handleQAReview(data: QAReviewData): Promise<void> {
  const { initiativeId, featureId, targetRepo, baseBranch } = data;

  await featureService.updateFeatureStatus(featureId, "qa_review");

  try {
    const feature = await featureService.getFeatureById(featureId);
    if (!feature) throw new Error(`Feature ${featureId} not found`);

    const initiative = await initiativeService.getInitiativeById(initiativeId);
    if (!initiative) throw new Error(`Initiative ${initiativeId} not found`);

    // Get diff
    const diff = await githubService.getBranchDiff(
      targetRepo,
      baseBranch,
      feature.branch_name!,
    );

    // Get changed files content
    const changedFiles = await githubService.getChangedFiles(
      targetRepo,
      feature.branch_name!,
      baseBranch,
    );

    // Run QA Agent
    log.info({ featureId }, "Running QA Agent");
    const qaResult = await runQAAgent({
      initiativeId,
      feature,
      initiative,
      diff,
      changedFiles,
    });

    if (qaResult.approved) {
      // Create PR
      log.info({ featureId }, "QA approved, creating PR");
      const pr = await githubService.createPullRequest(
        targetRepo,
        feature.branch_name!,
        baseBranch,
        `[BADS] ${feature.title}`,
        formatPRDescription(feature, qaResult),
      );

      await featureService.updateFeatureStatus(featureId, "human_review", {
        pr_number: pr.number,
        pr_url: pr.url,
      });

      await enqueueNotifyHuman({
        initiativeId,
        featureId,
        prUrl: pr.url,
      });
    } else if (feature.retry_count < QA_MAX_REJECTION_RETRIES) {
      // Retry development with QA feedback
      log.info({ featureId, retryCount: feature.retry_count }, "QA rejected, retrying");
      await featureService.updateFeatureStatus(featureId, "developing", {
        retry_count: feature.retry_count + 1,
      });

      await enqueueDevelopFeature({
        initiativeId,
        featureId,
        targetRepo,
        baseBranch,
        rejectionFeedback: qaResult.issues.join("\n"),
      });
    } else {
      log.warn({ featureId }, "QA rejected, max retries reached");
      await featureService.updateFeatureStatus(featureId, "failed");
    }
  } catch (err) {
    log.error({ err, featureId }, "QA review failed");
    await featureService.updateFeatureStatus(featureId, "failed");
    throw err;
  }
}

function formatPRDescription(
  feature: { title: string; description: string; acceptance_criteria: string[] | null },
  qaResult: { score: number; checklist: string[] },
): string {
  return `## Feature
**${feature.title}**

${feature.description}

## Acceptance Criteria
${(feature.acceptance_criteria ?? []).map((c) => `- [ ] ${c}`).join("\n")}

## QA Review
**Score:** ${qaResult.score}/10

${qaResult.checklist.map((c) => `- ${c}`).join("\n")}

---
*Generated by BADS*`;
}
